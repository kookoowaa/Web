# 클래스형 뷰

- 뷰는 요청을 받아서 응답을 반환해주는 **호출 가능한 객체<sup>callable</sup>**임
- 지금까지는 뷰를 함수로 작성하였지만, 상속과 믹스인 기능을 통해 재사용이 가능한 클래스형 뷰가 장점이 많음
- 간단한 경우에는 함수형 뷰로 신속하게 개발하는 것도 장점이 있지만 로직이 복잡해지고 프로젝트가 커질수록 클래스형 뷰의 장점이 부각됨

___

## 1. 클래스형 뷰의 시작점

- 클래스형 뷰를 사용하기 위해서는 먼저 URLconf에서 함수형 뷰 대신 클래스형 뷰를 사용한다는 점을 명시할 필요가 있음

- 예를 들어 MyView라는 클래스형 뷰를 사용한다면, URLconf는 다음과 같게 됨

  ```python
  ## urls.py
  
  from django.urls import path
  from myapp.views import MyView
  
  urlpatterns = [
      path('about/', MyView.as_view())
  ]
  ```

- 여기서 클래스형 뷰는 클래스로 진입하기 위해 **`as_view()`** 클래스 메소드를 사용

- `as_view()` 진입 메소드의 역할은 클래스의 인스턴스를 생성하고, 해당 인스턴스의 `dispatch()` 메소드를 호출

- `dispatch()` 메소드는 요청을 검사해서 GET, POST 등의 어떤 HTTP 메소드로 요청되었는지 확인 후 해당 이름을 갖는 메소드로 요청을 중계

- 만일 메소드가 정의되어 있지 않으면 **HttpResponseNotAllowed** 익셉션을 발생

- 여기서 MyView 클래스는 다음과 같이 `views.py` 파일 내 코딩

  ```python
  ## views.py
  
  from django.http import HttpResponse
  from django.views.generic import View
  
  class MyView(View):
      def get(self, request):
          # 뷰 로직
          return HttpResponse('result')
  ```

- 위의 `as_view()`나 `dispatch()` 함수는 장고에서 기본적으로 제공함으로 별도 정의가 필요하지는 않음

## 2. 클래스형 뷰의 장점 - 효율적인 메소드 구분



## 3. 클래스형 뷰의 장점 - 상속 기능 



## 4. 클래스형 제네릭 뷰



## 5. 클래스형 뷰에서 폼 처리



