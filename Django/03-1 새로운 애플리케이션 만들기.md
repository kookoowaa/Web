# 새로운 어플리케이션 만들기

> - 이전 챕터의 **polls** 어플리케이션 대신 **books** 라은 어플리케이션을 코딩할 예정
> - **books**는 책을 출판하는데 필요한 정보들인 책, 저자, 출판사에 대한 정보들을 관리하는 웹 어플리케이션이 될 예정
> - 앞서 polls 어플리케이션이 함수형 뷰 위주로 작성이 되었다면, books 어플리케이션은 클래스형 뷰 위주로 어플리케이션을 만들 예정
> - 프로젝트는 앞서 사용한 mysite를 그대로 사용하고, 하위에 books 어플리케이션을 생성

## 1. 어플리케이션 설계하기

- 우리가 개발할 books 어플리케이션의 내용은 책, 저자, 출판사의 정보를 관리하는, 즉 **정보를 보여주고 입력, 수정, 삭제**할 수 있는 웹 어플리케이션임

- 아래와 같이 UI, 테이블, 뷰의 흐름을 설계:

  *UI 설계*

  |        | index.html                            | book_list.html                                               | book_detail.html                                             |
  | ------ | ------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | 타이틀 | Book Mgmt System                      | Book List                                                    | Python Web Programming                                       |
  | 내용   | - Book<br />- Author<br />- Publisher | - Python Web Programming<br />- Design Pattern<br />- Effective Java | - Author: S. H. Kim<br />- Publiser: Hanbit<br />- Publication date: Mar 1, 2015 |

  *Book 테이블 설계*

  | 컬럼명           | 타입         | 제약조건                          | 설명         |
  | ---------------- | ------------ | --------------------------------- | ------------ |
  | id               | integer      | NotNull, PK, AutoIncrement        | Primary Key  |
  | title            | varchar(100) | NotNull                           | 책 제목      |
  | authors          | integer      | NotNull, MTM (Author.id), index   | Many-To-Many |
  | publisher        | integer      | NotNull, FK (Publisher.id), index | Foreign Key  |
  | publication_date | date         | NotNull                           | 책 출판일    |

  *Author 테이블 설계*

  | 컬럼명     | 타입         | 제약조건                   | 설명        |
  | ---------- | ------------ | -------------------------- | ----------- |
  | id         | integer      | NotNull, PK, AutoIncrement | Primary Key |
  | salutation | varchar(100) | NotNull                    | 저자 인사말 |
  | name       | varchar(50)  | NotNull                    | 저자 성명   |
  | email      | email        | NotNull                    | 저자 이메일 |

  *Publisher 테이블 설계*

  | 컬럼명  | 타입         | 제약조건                   | 설명            |
  | ------- | ------------ | -------------------------- | --------------- |
  | id      | integer      | NotNull, PK, AutoIncrement | Primary Key     |
  | name    | varchar(50)  | NotNull                    | 출판사 이름     |
  | address | varchar(200) | NotNull                    | 출판사 주소     |
  | website | url          | NotNull                    | 출판사 홈페이지 |

  *뷰 흐름 설계*

  | URL            |      | View                         |      | Template             |
  | -------------- | ---- | ---------------------------- | ---- | -------------------- |
  | /books/        | >    | **BooksModelView.as_view()** | >    | **index.html**       |
  | /books/book/   | >    | **BookList.as_view()**       | >    | **book_list.html**   |
  | /books/book/3/ | >    | **BookDetail.as_view()**     | >    | **book_detail.html** |

## 2. 어플리케이션 추가

- 이번 예제에서는 mysite라는 기존의 프로젝트를 사용하기에, books 어플리케이션만 추가하면 됨

  ```shell
  ~ cd C:\Git\Web\Django\ch5
  C:\Git\Web\Django\ch5> python manage.py startapp books
  ```

- 프로젝트에 포함되는 어플리케이션을 설정파일에 등록 (모듈명인 books 등록 가능)

  ```python
  # mysite/settings.py
  
  INSTALLED_APPS = [
      'django.contrib.admin',
      'django.contrib.auth',
      'django.contrib.contenttypes',
      'django.contrib.sessions',
      'django.contrib.messages',
      'django.contrib.staticfiles',
      'polls.apps.PollsConfig',
      'books.apps.BooksConfig',
  ]
  ```


## 3. Model 코딩하기

- DB 관련 작업은 앞 장 예제에서 한차례 다뤘듯이 아래와 같은 순서대로 진행:

  > - `models.py` 정의
  > - `admins.py` 정의 
  > - `manage.py makemigrations` 변경사항 추출
  > - `manage.py migrate` 변경사항 반영
  > - `manage.py runserver` 개발용 웹서버로 확인

  ```python
  # ch5/books/models.py
  
  from django.db import models
  
  class Book(models.Model):
      title = models.CharField(max_length = 100)
      authors = models.models.ManyToManyField("Author")
      publisher = models.ForeignKey('Publisher', on_delete=models.CASCADE)
      publication_date = models.DateField()
  
      def __str__(self):
          return self.title
  
  
  class Author(models.Model):
      name = models.CharField(max_length=50)
      salutation = models.CharField(max_length=100)
      email = models.EmailField()
  
      def __str__(self):
          return self.name
  
  
  class Publisher(models.Model):
      name = models.CharField(max_length=50)
      address = models.CharField(max_length=100)
      website = models.URLField()
  
      def __str__(self):
          return self.name
  ```

  ```python
  # ch5/books/admin.py
  
  from django.contrib import admin
  from books.models import Book, Author, Publisher
  
  admin.site.register(Book)
  admin.site.register(Author)
  admin.site.register(Publisher)
  ```

- 아래 명령어로 위 변경 사항을 데이터베이스에 반영

  ```shell
  ~> cd c:\git\Web\Django\ch5
  ..ch5> python manage.py makemigrations
  ..ch5> python manage.py migrate
  ```

- *만약 위와 같이 작업 후에도 admin 사이트에서 테이블을 확인할 수 없다면, `mysite/settings.py`에 어플리케이션이 추가되었는지 확인 필요*

## 4. URLconf 코딩하기

- URL은 `mysite/urls.py`와 `books/urls.py` 양쪽에 내용을 추가

- 2절의 뷰 흐름 내용을 참고해서 URLconf 정의

  ```python
  # mysite/urls.py
  
  from django.contrib import admin
  from django.urls import path, include
  
  urlpatterns = [
      path('admin/', admin.site.urls),
      path('polls/', include('polls.urls')),
      path('books/', include('books.urls')),
  ]
  ```

  ```python
  # books/urls.py
  
  from django.urls import path
  from . import views
  
  app_name='books'
  urlpatterns = [
      # /books/
      path('', views.BooksModelView.as_view(), name = 'index'),
  
      # /books/book/
      path('book/', views.BookList.as_view(), name='book_list'),
  
      # /books/author/
      path('author/', views.AuthorList.as_view(), name='author_list'),
  
      # /books/publisher/
      path('publisher/', views.PublisherList.as_view(), name='publisher_lsit'),
  
      # /books/book/99/
      path('book/<int:pk>/', views.BookDetail.as_view(), name='book_detail'),
  
      # /books/author/99/
      path('author/<int:pk>/', views.AuthorDetail.as_view(), name='author_detail'),
  
      # /books/publisher/99/
      path('publisher/<int:pk>/', views.PublisherDetail.as_view(), name='publisher_detail'),
  ]
  ```

- 총 7개의 URL을 정의하였고, 클래스형 뷰 역시 7개를 정의

- 클래스형 뷰로 정의하기 위해 각 URL에 따른 뷰 클래스 및 `as_view()` 메소드를 지정

- 템플릿 파일도 각각 하나씩 총 7개가 필요 (꼭 1:1의 관계가 요구되는 것은 아님)

## 5. 클래스형 View 코딩하기

- 위에서 지정한 뷰를 코딩:

  ```python
  # books/views.py
  
  from django.views.generic.base import TemplateView
  from django.views.generic import ListView, DetailView
  from books.models import Book, Author, Publisher
  from django.shortcuts import render
  
  
  #-- TemplateView
  class BooksModelView(TemplateView):
      template_name = 'books/index.html'
  
      def get_context_data(self, **kwargs):
          context =  super().get_context_data(**kwargs)
          context['model_list'] = ['Book', 'Author', 'Publisher']
          return context
  
  
  #-- ListView
  class BookList(ListView):
      model = Book
  
  class AuthorList(ListView):
      model = Author
  
  class PublisherList(ListView):
      model = Publisher
  
  
  #-- DetailView
  class BookDetail(DetailView):
      model = Book
  
  class AuthorDetail(DetailView):
      model = Author
  
  class PublisherDetail(DetailView):
      model = Publisher
  ```

  > - `BooksModelView(TemplateView)`는 제네릭뷰의 **`TemplateView`**를 상속받음
  > - **`TemplateView`**는 특별한 로직 대신 템플릿 파일만을 렌더링 하는 경우에 사용 (단, 필수적으로 `template_name` 클래스 변수를 오버라이딩해서 지정해 주어야 하며, 템플릿 시스템으로 넘겨줄 변수가 있는 경우 `super().get_context_data(**kwargs)`를 오버라이딩해서 정의 )
  > - `BookList()`, `AuthorList()`, `PublisherList()`는 모두 제네릭뷰 **`ListView`**를 상속받음
  > - 이 경우 객체가 들어있는 리스트를 구성해서 이를 컨텍스트 변수로 템플릿 시스템에 전달 (모델 클래스명만 지정해주면 되며 이 경우 Book, Author, Publisher 테이블을 그대로 가져와 `object_list`라는 디폴트 컨텍스트 변수를 구성)
  > - 또한, **`ListView`**는 디폴트로 템플릿 파일을 `모델명소문자_list.html` 형식의 이름으로 지정 (위의 경우 `books/book_list.html`, `books/author_list.html`, `books/publisher_list.html`이 됨)
  > - `BookDetail()`, `AuthorDetail()`, `PublisherDetail()`은 제네릭뷰 **`DetailView`**를 상속받음
  > - **`DetailView`**는 특정 객체 하나를 컨텍스트 변수에 담아서 템플릿 시스템에 전달 (만일 테이블에서 PK로 조회해서 객체를 가져오는 경우 테이블명만 지정해 주면 되고, PK값은 URLconf에서 추출하여 뷰로 넘어온 파라미터 사용)
  > - **`DetailView`**는 디폴트로 object 변수를 반환하며, `ListView`와 마찬가지로 `모델명소문자_detail.html`을 이름으로 지정

- 장고의 강점은 이같은 제네릭뷰의 강력함으로 DB를 활용하여 객체의 리스트를 보여주거나 활용할 때 장점이 부각

- 기본적인 로직은 장고에서 모두 처리해 주고, 개발자는 단 2줄로 코딩을 완료

## 6. Template 코딩하기

- 뷰 클래스가 7개이고 템플릿 파일도 아래와 같이 7개가 필요(`books/templates/books`):

  | URL 패턴            | 뷰 클래스명     | 템플릿 파일명         | 템플릿 설명                |
  | ------------------- | --------------- | --------------------- | -------------------------- |
  | /books/             | BookModelView   | index.html            | books 어플리케이션 첫 화면 |
  | /books/book/        | BookList        | book_list.html        | 책 리스트 반환             |
  | /books/author/      | AuthorList      | author_list.html      | 저자 리스트 반환           |
  | /books/publisher/   | PublisherList   | publisher_list.html   | 출판사 리스트 반환         |
  | /books/book/3/      | BookDetail      | book_detail.html      | 특정 책의 상세정보 반환    |
  | /books/author/3/    | AuthorDetail    | author_detail.html    | 특정 저자 상세정보 반환    |
  | /books/publisher/3/ | PublisherDetail | publisher_detail.html | 특정 출판사 상세정보 반환  |

- 순서대로 `index.html`, `xxx_list.html`, `xxx_detail.html` 순으로 확인

  ```django
  {# index.html #}
  
  {% extends "base_books.html" %}
  
  {% block content%}
  <h2>
      Books Management System
  </h2>
  <ul>
      {% for modelname in model_list %}
      {% with "books:"|add:modelname|lower|add:"_list" as urlvar %}
      <li><a href="{%url urlvar %}">{{ modelname }}</a></li>
      {% endwith %}
      {% endfor %}
  </ul>
  
  {% endblock content %}
  ```

  